# C#「null 合体演算子」完全ガイド

## — ?? と ??= で"null チェック＋代入"を 1 行に —

### 対象読者
- C# 初〜中級者
- `if (x == null)...` を減らしてコードをスッキリさせたい人


## 1. なぜ ?? / ??= が便利なのか
「null なら既定値を使う」「null なら初期化する」といった処理のたびに、
```csharp
if (userName == null)
{
    userName = "Guest";
}
```
このような3行 if を書くのって正直ちょっと面倒です。

`??` や `??=` を使えば、そうしたコードを1行にまとめられます。
- インデントが浅くなる → 読みやすい
- nullチェック漏れによるバグも減る
- LINQ や式メンバーと相性がよく、柔軟に使える

しかもこれ、実際に使ってみると「あ、これ良いやつだ」と体感できる系です。


## 2. 基本文法
| 演算子 | 意味 | 戻り値 | 典型用途 |
|-------|-----|-------|---------|
| `x ?? y` | x が null なら y | x または y | 既定値の適用 |
| `x ??= y` | x が null なら y を代入し、その結果を返す | 代入後の x | 遅延初期化・キャッシュ処理 |

※どちらも右結合です。優先順位は ?: より高く、|| より低め。
（参考：[C# Operator Precedence - Microsoft Docs](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/#operator-precedence)）


## 3. ?? の使いどころ

### 3-1. 既定値の適用
```csharp
string displayName = user.DisplayName ?? "（名無し）";
```
「nullだったら"名無し"で表示」といった典型例ですね。

### 3-2. コンフィグ値のフェールセーフ
```csharp
int port = int.TryParse(cfg["Port"], out var p) ? p : (int?)null 
           ?? 8080;
```
設定値がパースできなかった場合に 8080 などのデフォルト値を入れておくテク。

### 3-3. null 条件演算子 (?.) と併用
```csharp
var country = order?.ShippingAddress?.Country ?? "JP";
```
これもよくある使い方。null なら "JP" として処理を進める感じ。やりすぎるとデバッグが大変なので程よく使うのが良いかなと。


## 4. ??= で"遅延初期化"

### 4-1. 単純キャッシュ
```csharp
private Dictionary<int, Product>? _cache;

public Dictionary<int, Product> Cache
{
    get => _cache ??= LoadProducts();
}
```
一度しか呼ばない処理をキャッシュして、以降は使い回したい時に便利。

この `_cache ??= LoadProducts()` の式、
- `_cache` が `null` → `LoadProducts()` を実行して代入
- `null じゃない` → そのまま `_cache` を返す

というふうに動きます。

つまり、「初アクセス時にだけ実体を作る」という使い方が可能。これがいわゆる「**遅延初期化**」です。

一度キャッシュに入ったあとは、以降ずっと同じオブジェクトが返ってくるので、
「重たい処理を何度も走らせたくない」ときにピッタリ。

> ✅ 実行されるのは `null` の時だけ！
> なので「必要になるまで作らない」コードにしたい時に活躍します。

> 💬 補足：「キャッシュ」と言っても、これはアプリ内の話で、CPUのキャッシュメモリやブラウザのキャッシュとは別物です。
> `cache` の語源はフランス語の *cacher*（隠す）で、「とりあえずすぐ使えるように大事にとっとく」みたいなニュアンス。Webアプリではブラウザが保持するキャッシュ、デスクトップアプリなら OS が一時ファイルとしてキャッシュを持つこともありますが、ここで言うキャッシュは「アプリケーション内でオブジェクトを使い回すための一時保管場所」と捉えてOKです。

### 4-2. ループ内のコレクション生成（HashSet を使った代替も）

このパターン、見た目はシンプルですがかなり実用的です。

```csharp
var groups = new Dictionary<string, List<Item>>();

foreach (var item in items)
{
    (groups[item.Category] ??= new()).Add(item);
}
```
初めて出てきたカテゴリだけ `new()` してリストを生成。
2回目以降は既存のリストに `.Add()` するだけ。

このコードは、カテゴリごとに `Item` をまとめたいときに便利です。
例えば「カテゴリがユニークなキーになる」ような処理で、
SQL でいうところの `GROUP BY` に近い集約のイメージですね。

別の視点でいえば、`groups.ContainsKey()` のチェックを省略しながら
「存在しなければ作って追加」というよくある処理を、1行でサラッと書けるのが魅力です。

なお、カテゴリ自体の重複を避けて一意に取り出したい場合は LINQ の `Distinct()` などと組み合わせることで、より"ユニーク寄り"の使い方もできます。

意外とこのパターン、日常のバッチ処理や集計ロジックでよく使われています。

ちなみに「カテゴリが重複しないようにだけしておきたい（＝ユニークにしたい）」という目的なら、`Dictionary<string, List<Item>>` ではなく `HashSet<string>` を使うのも手です。
[HashSetの詳細はMicrosoft Docsを参照](https://learn.microsoft.com/en-us/dotnet/fundamentals/runtime-libraries/system-collections-generic-hashset-t)


## 5. よくあるQ & A
| Q | 解説 |
|---|-----|
| 値型でも使える？ | `int?` などの nullable 型なら OK。int 単体には意味なし。 |
| 右側は毎回評価される？ | 左辺が null のときのみ実行される。つまり **遅延評価**。 |
| 副作用のある式に注意 | `obj ?? DoSomething()` は obj が null なら DoSomething() が呼ばれる。予期せぬ副作用は注意。 |
| null許容参照型 (string?) との併用 | `??` の後は非 null とみなされるため `!` 演算子は原則不要。 |


## 6. 実務 Tips

- `if (x == null)` が2行以上連続してたら `??` / `??=` にできないか見直す
- 戻り値にデフォルトを返すか、例外を投げるかはチームで方針を決めておくと◎
- `?. + ??` は便利だけど、ネストが深くなると可読性が犠牲になる
    - DTO 変換時に一度フラットにする
    - 局所変数に割って読みやすさ優先


## 7. まとめ

`??` や `??=` は、

> 「null だったら 1 行で片付けよう」

という、今どきの C# に欠かせない構文です。

「この if 文、もっと短くできる気がする…」と思ったときにまず思い出してみてください。

**ネストを減らし、バグも減らし、レビューもラクになる。**

こういう"ちょっとした工夫"が、実はコード全体のクオリティを底上げしてくれたりするんですよね。

最初は既存コードの `if (x == null)` を見つけて `??` に書き換えてみるところから。ぜひ試してみてください。